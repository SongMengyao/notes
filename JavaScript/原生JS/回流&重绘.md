[返回目录](../原生JS.md)

**` 回流 & 重绘 `**

**回流一定会引起重绘，重绘不一定引起回流**, 所以回流的代价大于重绘。

render tree 是 DOM tree 和 css 的结合体，不包含display等于none的节点。

- 回流：

    `当 render tree 中的元素的大小、尺寸、布局、隐藏等属性发生变化时，就需要重新构建，这就是回流。`

    每个页面都至少有一次回流，就是页面在第一次加载的时候，需要构建 render tree ，这时就发生了回流。

  - 回流的过程：

    在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。


- 重绘：

  `当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color，这就叫重绘。`


- 回流 和 重绘 的区别：

  `回流必将引起重绘，而重绘不一定会引起回流。`比如：只有颜色改变的时候就只会发生重绘而不会引起回流。当页面布局和几何属性改变时就需要回流，比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变


- 优化：
  - 浏览器的帮忙：

    `回流比重绘的代价要更高，回流的花销跟 render tree 有多少节点需要重新构建有关系。`因为这些机制的存在，所以浏览器会帮助我们优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。

  - 自己的优化：

    改变一些写法减少回流和重绘。比如改变样式的时候，不去改变他们每个的样式，而是直接改变 className， 就要用到 cssText， 但是要注意有一个问题，会把原有的 cssText 清掉，比如原来的 style 中有 ’display:none;’，那么执行完上面的 JS 后，display 就被删掉了。为了解决这个问题，可以采用 cssText 累加的方法，但是 IE 不支持累加，前面添一个分号可以解决。还有添加节点的时候比如要添加一个div里面有三个子元素p，如果添加div再在里面添加三次p，这样就触发很多次回流和重绘，我们可以用cloneNode(true or false) 来避免，一次把要添加的都克隆好再 appened就好了。等等很多


[返回目录](../原生JS.md)
